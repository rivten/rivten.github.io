<!doctype html><html lang=en><head><title>Article Study : Surface Simplification using Quadric Error Metrics &ndash; rivten - blog</title><meta name=description content="stuck here"><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=stylesheet href=https://rivten.github.io/css/colour/srcery-dark.css><link rel=stylesheet href=https://rivten.github.io/css/colour/dark-mode.css><link rel=stylesheet href=https://rivten.github.io/css/risotto.css><link rel=stylesheet href=https://rivten.github.io/css/custom.css></head><body><div class=page><header class=page__header><h1 class=page__logo><a href=https://rivten.github.io/ class=page__logo-inner>rivten - blog</a></h1><nav class="page__nav main-nav"><ul><li class=main-nav__item><a class=nav-main-item href=/about/ title>about</a></li><li class=main-nav__item><a class="nav-main-item active" href=/posts/ title=Posts>Posts</a></li></ul><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></nav></header><section class=page__body><header class=content__header><h1>Article Study : Surface Simplification using Quadric Error Metrics</h1></header><div class=content__body><h1 id=an-article-study-series->An article study series ?</h1><p>Lately, I have been reading a lot of scientific papers about various topics : computer graphics, physics or mesh processing. I found that it is very interesting to have an insight about a particular field and understand what is at stake and where the current research efforts are today.</p><p>It struck me that I could do this while watching <a href="https://www.youtube.com/watch?v=SDS5gLSiLg0">Casey Muratori&rsquo;s video on Papers we Love</a>. I wanted to get people excited about stuff happening in the scientific world and&mldr; it is not even that hard to understand really. So today, I give this idea a shot. My goal is to explain a particular scientific article, because of the repercussion it had or the new vision it brought, by outlining the basic scientific arguments it presents and highlighting the important ideas the authors contributed to. I will assume that you are somewhat familiar with some concepts (basic linear algebra, &mldr;) and I will try to explain notions as much as possible, or give references to look up to if you are lost.</p><p>This being the first article study of the series, I chose to present a very famous article published about 20 years ago on 3D polygon simplification who had a big impact on how the community understand mesh processing nowadays.</p><h1 id=did-you-say-mesh->Did you say mesh ?</h1><p>In 3D graphics, for a game or for movie production for example, people usually handle 3-dimensional models of objects they want rendered. Those models are called meshes or polygon meshes and consist &ndash; mostly &ndash; of three things : vertices, edges and faces<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. Vertices are basically points with some data associated, typically position, normal and color. Edges are links between vertices and finally faces are triangles with three edges<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. This whole data caracterizes a mesh that then will be lighted, shadowed, animated and rendered by a rendering engine.</p><p><img src=/images/mesh_simplification/dragon_mesh.png alt="Here a mesh from a dragon in Skyrim"></p><h1 id=surface-simplification-why->Surface Simplification. Why ?</h1><p>The article I want to highlight today is called : <em>Surface Simplification using Quadric Error Metric</em> and was published in 1997 by Michael Garland and Paul S. Heckbert. This paper discuss how to simplify a given mesh into another one having less vertices / edges / faces.</p><p>But why is it an important matter ? Well because there is a trade-off to be found between performance and quality. A mesh having a lot of faces will be highly detailed, therefore will probably be a high-quality polygon. However, processing such a large amount of triangles will create performance issue : if you want to render a character mesh for a game, you only have a few milliseconds to process all the vertices in the mesh, so you might want to first <em>simplify</em> its geometric representation before processing it. Then again, the result will be of a lesser quality, but you will achieve better performance. It is up to you which trade-off you are aiming for.</p><p><img src=/images/mesh_simplification/mesh_simplification.png alt="A mesh with several simplification steps"></p><p>With this framework in mind, you can now see what is the issue Garland and Heckbert were tackling 20 years ago : how to automate mesh simplification efficiently while not changing the overall structure of the mesh (i.e. minimizing the error between the input mesh and the result of the algorithm).</p><p>More formally, in the global surface simplification framework, there is a trade-off to be made between having a small amount of vertices but a big deviation from the original mesh, or a small deviation from the original mesh and still a big amount of vertices. Therefore, a rigorous mesh simplification problem is one of the following. Given an input mesh $M_i$ with $V_i$ vertices, an error function $\text{Err}$ (which measures of much two meshes deviates from one another), I want to have a resulting mesh $M_r$ with $V_r$ vertices such that either :</p><ol><li>we want to minimize $V_r$ under the constraint $\text{Err}(M_i, M_r) \leq \epsilon$ for a given $\epsilon$</li><li>we want to minimize $\text{ Err}(M_i, M_r)$ under the constraint $V_r \leq M$ for a given $M$</li></ol><p>In the first statement of the problem, we do not want the resulting mesh to deviate too much from the input mesh, while reducing the number of vertices as much as possible. Whereas in the second statement, we want to reach a certain amount of maximum vertices and then be as close as possible from the input mesh. Those two statements looks quite the same, but there subtle difference lay in the constraint they set themselves (deviation or vertex count) to achieve their simplification goal.</p><p>The algorithm proposed by Garland and Heckbert can fullfill both of these statements. I will now explain the algorithm they proposed back then.</p><h1 id=contracting-edges>Contracting edges</h1><p>It is clear that, if you want to reduce the amount of vertices in a mesh in order to simplify it, you have to have a basic operator to apply to you mesh. The operator used by Garland and Heckbert is a very common yet useful one and is called the <em>edge contraction operator</em>. The basic idea is to take a pair of vertices $v_1$ and $v_2$, remove the edge between them and create a new vertex $\bar{v}$ as shown in the next diagram.</p><p><img src=/images/mesh_simplification/edge_contraction_operator.png alt="Edge contraction operator"></p><p>This operator is formally written as</p><p>$$(v_1, v_2) \rightarrow \bar{v}$$</p><p>This is the main operation that will be performed by the algorithm in the course of the processing. There is, however, several issues raised by this operator concerning the topology of the resulting mesh that I will not discuss here<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><p>Now that we have this basic operation in our hand, we are one step closer to the result we are looking for. But there are still some holes to be filled : to which pair do we apply this operator to ? and how to find which optimal resulting vertex $\bar{v}$ to use ?</p><h1 id=selecting-vertex-pairs>Selecting vertex pairs</h1><p>The first of the two question is actually pretty simple. We have to give some criteria to select which pair will be eligible to be contracted. Garland and Heckbert, in their paper, proposed the following. They defined a pair of vertices $(v_1, v_2)$ to be <em>valid</em> for contraction if</p><ol><li>$(v_1, v_2)$ is an edge in the input mesh</li><li>$||v_1 - v_2|| &lt; t$ where t is a threshold parameter</li></ol><p>$t$ is a parameter that we can play with. If $t = 0$, then only the actual edges of the mesh will be collapsed. This will have the benefit of not touching the overall topology of our polygon, but may cause pairs that would have been interesting to collapse to stay untouched. On the other hand, if $t$ is too big, two vertices that are unrelated - because they are very far away from each other in the initial mesh - may be collapsed, causing the resulting mesh to deviate too much from the original one.</p><h1 id=chosing-the-optimal-contraction-result-from-quadric-error>Chosing the optimal contraction result from quadric error</h1><p>Now we know we want to perform a contraction $(v_1, v_2) \rightarrow \bar{v}$ on a valid pair. The question now is : where do I place the resulting vertex $\bar{v}$ ? What should the result of the contraction be ?</p><p>Well, this we do not want the resulting mesh to deviate too much from the original one, we ought to place this new vertex carefully, at a place where it will minimize the overall error between $M_i$ and $M_r$. For this, we need to define what is the error we make by replacing the pair $(v_1, v_2)$ by $\bar{v}$.</p><p>Garland and Heckbert first noticed that, considering one vertex $v_1$, each triangle that had $v_1$ as one of its vertices was defining a plane from which $v_1$ was a part of. One could also compute the squared distance from a vertex $v$ and that very plane. Indeed, if $v = (x, y, z, 1)$<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> and the plane $P$ had the equation $ax + by + cy + d = 0$ then we would have</p><p>$$\text{d}(v, P)^2 = v^\top Q_P v$$</p><p>where $\text{d}$ is the Euclidian distance and $Q_P$ is a 4x4 symmetric matrix representing a quadric matrix of the plane.</p><p>$$ Q_P = \left (
\begin{array}[cccc]\
a^2 & ab & ac & ad \
ab & b^2 & bc & bd \
ac & bc & c^2 & cd \
ad & bd & cd & d^2
\end{array}
\right)$$</p><p>So that computing a distance of a vertex to a plane boils down to matrix multiplication. Quite easy !
In order to measure the deviation at a particular vertex, we can define $Q_v$ the <em>quadric matrix of a vertex</em> $v$ as the sum of all the quadric matrix of the planes of the triangles that have $v$ as a vertex. If $\mathbb{P}$ is the set of the planes supported by triangles of $v$ then</p><p>$$Q_v = \sum_{P \in \mathbb{P}} Q_P$$</p><p>Now we can define the overall error of a vertex contraction. Considering the operation $(v_1, v_2) \rightarrow \bar{v}$, we have, as previously defined, a quadric cmatrix $Q_1$ and a matrix $Q_2$ at hand (one for each vertex). So, for a vertex $\bar{v}$ we can now define the error $\Delta$ by</p><p>$$\Delta(\bar{v}) = \bar{v}^\top \left( Q_1 + Q_2 \right) \bar{v} = \bar{v}^\top Q_e \bar{v}$$</p><p>where $Q_e$ is the final quadric error estimator<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>.</p><p>Phew. So we have defined what is the error we do when we contract a pair into one vertex. Now, our goal is to minimize this error, i.e. finding $\bar{v}$ so that $\Delta(\bar{v})$ is minimal.</p><p>If we rewrite $Q_e$ so that</p><p>$$ Q_e = \left (
\begin{array}[cc]\
A & -f \
-f^\top & g \
\end{array}
\right)$$</p><p>then, one can show by computing direct derivative along $x$, $y$ and $z$ that minimizing $\bar{v}^\top Q_e \bar{v}$ is equivalent to solving the system</p><p>$$ Av = f$$</p><p>Now, either $A$ is invertible, and we directly have our optimal point $\bar{v}$ at hand. If $A$ is not invertible, we can always fall back to some simple, but less precise methods such as chosing $\bar{v} = \left( v_1 + v_2\right) / 2$ for example.</p><h1 id=algorithm-outline>Algorithm outline</h1><p>We have now defined all the concepts necessary to provide an algorithm. Indeed, we know how to contract vertices, which one to contract, and what the result of the contraction should be. We now need an efficient way to process the mesh. Garland and Heckbert proposed the following steps.</p><ol><li>Compute the quadric matrix $Q$ of each vertex.</li><li>Compute the list of all valid pairs of vertices.</li><li>Compute the optimal contraction target $\bar{v}$ for each valid pair. The <em>cost</em> of that pair is defined as $\Delta(\bar{v})$</li><li>Sort the list of pairs with increasing cost (so that the pair of lowest cost is first)</li><li>Iteratively removed the pair of lowest cost from the list. Contract this pair. Update the costs of all valid pair involving the contracted vertices.</li></ol><p>You can stop this algorithm whenever you have reach the goal you set yourself in the third section, either you have reach the amount of vertex you want to have, either contracting another pair would make the overall error too big.</p><h1 id=why-this-is-great-and-where-to-go-from-there>Why this is great and where to go from there</h1><p>The algorithm presented by Garland and Heckbert in 1997 works quite well and efficiently on a large number of meshes without destroying too much their topology.</p><p><img src=/images/mesh_simplification/cow_simplified.png alt="Result of algorithm"></p><p>What is so great about this algorithm is that it first proposes to contract pair that do not have a big impact on the resulting mesh (i.e. those that have the lowest cost) while still constantly reducing the amount of vertices.Moreover, the heuristic chosen, the quadric, to evaluate the error made by a compression provides less coarser result for the pair contraction.</p><p>Even though this article was published almost 20 years ago, it outlined the basis for most mesh simplification algorithms. For example, we could talk about the article <em>Structure Aware Mesh Decimation</em> that takes this very idea of edge contraction, but gives a more refined and precise heuristic to evaluate the error of the contraction.</p><h1 id=references>References</h1><ul><li><a href=http://mgarland.org/files/papers/quadrics.pdf>The original article by Garland and Heckbert</a></li><li>An extention of the article : <a href=https://hal.inria.fr/hal-01111203/file/structure%20(1).pdf>Structure Aware Mesh Decimation</a></li><li><a href=http://meshlab.sourceforge.net/>Meshlab</a> : an open-source mesh manipulation tool in which mesh simplification is available</li></ul><hr><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>We can define more generally a mesh in the context of <em>algebraic topology</em> with the notion of <em>simplicial complex</em>. This theory is called <em>homology theory</em> and you might want to learn more about this by googling those terms if you have a strong mathematical background.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Faces in the mesh are not always triangles. They can be quads for examples. Triangles are widly used however.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>For more details, you can refer to the original article. Fully explaining the topology issues at stake here is out of the scope of this article.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>We are using homogenous coordinates here. If you are unfamiliar with this concept, you can delve into this <a href=http://www.songho.ca/math/homogeneous/homogeneous.html>great introduction of homogenous coordinates</a>. Basically, we add a forth dimension to a vector to be able to determine whether this point lays at the infinity.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>Notice that this estimator is the sum of the squared distances of the planes of $v_1$ and $v_2$ to $\bar{v}$&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=content__footer></footer></section><section class=page__aside><div class=aside__about><div class=aside__about><h1 class=about__title>rivten</h1><p class=about__description>stuck here</p></div><ul class=aside__social-links></ul></div><hr><div class=aside__content><p>by Hugo Viala,
2016-11-05</p></div></section><footer class=page__footer><p class=copyright></p></footer></div></body></html>