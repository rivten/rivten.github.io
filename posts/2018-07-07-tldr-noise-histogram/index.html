<!doctype html><html lang=en><head><title>TL;DR of the paper 'High-Performance Procedural Noise using a Histogram-Preserving Blending Operator' &ndash; rivten - blog</title><meta name=description content="stuck here"><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><link rel=stylesheet href=https://rivten.github.io/css/colour/srcery-dark.css><link rel=stylesheet href=https://rivten.github.io/css/colour/dark-mode.css><link rel=stylesheet href=https://rivten.github.io/css/risotto.css><link rel=stylesheet href=https://rivten.github.io/css/custom.css><link rel=stylesheet href=https://rivten.github.io/css/syntax.css></head><body><div class=page><header class=page__header><h1 class=page__logo><a href=https://rivten.github.io/ class=page__logo-inner>rivten - blog</a></h1><nav class="page__nav main-nav"><ul><li class=main-nav__item><a class=nav-main-item href=/about/ title>about</a></li><li class=main-nav__item><a class="nav-main-item active" href=/posts/ title=Posts>Posts</a></li></ul><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></nav></header><section class=page__body><header class=content__header><h1>TL;DR of the paper &lsquo;High-Performance Procedural Noise using a Histogram-Preserving Blending Operator&rsquo;</h1></header><div class=content__body><p>Inspired by the work of <a href=https://twitter.com/erkaman2>Eric Arneb√§ck</a>, I wanted to try my own TLDR of graphics acamedic papers. In here, I want to describe the work of Eric Heitz and Fabrice Neyet in the paper <a href=https://hal.inria.fr/hal-01824773/document>High-Performance Procedural Noise using a Histogram-Preserving Blending Operator</a>. Please note that the images are directly taken from the paper and are not mine.</p><h1 id=the-problem>The problem</h1><p>Let&rsquo;s say an artist made a texture for the ground in your game, but he only did a small patch of the ground and you want to have the pattern repeat on a ground that is way larger than what the artist drew. You could have the texture repeat in a very simple fashion but this would be dull and ugly. What you really want is a fast way to generate a huge ground texture based on the feature of the smaller texture that the artist made.</p><p><img src=/images/histogram_article/hist_example.png alt="Example. On the left, small input textures. On the right, generated bigger textures."></p><p>So this is our problem, you are given a small noisy texture with high-frequency features and you want to generate quickly a much bigger texture from it.</p><h1 id=blending-textures>Blending textures</h1><p>One basic method for this kind of problem is to do the following : let&rsquo;s say you want to know the final color of one pixel of the final texture, you will pick three points from the initial texture and say that the final color will be a mix, a blending of the three initial colors. If we repeat this operation for each pixel in the final texture, we will have an output that looks a lot like the initial smaller texture. This computation could happen in a fragment shader so that we can generate everything at runtime.</p><p><img src=/images/histogram_article/hist_blending.png alt="Blending example"></p><p>The question is now : how do we blend the three initial pixels together ?</p><p>If we affect weights $w_1$, $w_2$ and $w_3$ to the pixels $X_1$, $X_2$ and $X_3$, one classic solution would be to do a linear blend between those to compute the final pixel $X$</p><p>$$ X&rsquo; = w_1 X_1 + w_2 X_2 + w_3 X_3 $$</p><p>But this solution does not work because this generates colors and contrasts in the final texture that are not present in the initial texture.</p><p>Therefore, the paper states that what needs to be preserved by the blending operation is the histogram of the initial texture.</p><h1 id=preserving-the-histogram>Preserving the histogram</h1><p>The histogram of a texture is the curve that gives us the number of pixels that have a specific intensity on the red, green or blue channel. If the initial texture&rsquo;s histogram and the final texture&rsquo;s histogram are almost the same, then we will have a satisfying result<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><p><img src=/images/histogram_article/hist_hist.png alt="Input Images with their respective histograms"></p><p>So now our problem is : what is the blending operator that preserves the texture&rsquo;s histogram ?</p><p>The authors note that there is a special case in which this problem is very easy : if the histogram corresponds to a Gaussian distribution of the colors, then a variance-blending operator exactly preserves the histogram. This is well-known and quite easy to compute<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. The problem is that, in the general case, the input color does not have an histogram that has a Gaussian distribution.</p><p>But, if we could transform our input image so that it has a Gaussian distribution, we could use our histogram-preserving operator to generate a bigger texture. This bigger texture would also have a Gaussian distribution, and then we could use the inverse transformation to go back to the initial histogram, but with the output texture. And we would win.</p><p>More formally, if we have an initial pixel of color $X$, that follows of initial distribution histogram $H$, we need to find an operator $T$ that transforms $X$ to have a pixel $G$ of Gaussian distribution.</p><p>$$ G = T(X)$$</p><p>If we have our blending operator $f$ that preserve the Gaussian histogram, then</p><p>$$ f(G) = f(T(X))$$</p><p>also have a Gaussian distribution. To get our final pixel color $X&rsquo;$ we just do the inverse operation of $T$, which is $T^{-1}$.</p><p>$$ X&rsquo; = T^{-1}[f(G)] = T^{-1}[f(T(X))]$$</p><p>This will effectively turn the Gaussian distribution into our initial histogram, but on a bigger texture. And we are done. Our histogram-preserving blending operator $f$ is well-known. So our question is now : what exactly are $T$ and $T^{-1}$?</p><p>$T$ must be an operator that transforms our input image so that it has a Gaussian distribution. This is a well-known complex problem and one possible solution is given by an Optimal Transport method<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>. Explaining the Optimal Transport is out of the scope of this post, but all we have to know is that, with this method, we can transform an image of any histogram into another image with an histogram of our choice, the problem is that this computation is very slow. Yet it could do the job if we use it smartly.</p><h1 id=the-final-algorithm>The final algorithm</h1><p>Now every elements are in our hand, $f$, $T$, and $T^{-1}$. But, as I said previously, $T$ is very costly to compute. So here is the method that the authors propose :</p><ul><li>In an offline pass, precompute $G = T(X)$ with the Optimal Transport method. So have the input transformed with a Gaussian distribution already at hand.</li></ul><p><img src=/images/histogram_article/hist_step1.png alt="Step 1 of the algorithm"></p><ul><li>Since we will need to compute $T^{-1}$ at runtime and since it is also costly to compute, precompute some value of $T^{-1}$ with the Optimal Transport method and store it in a look-up table.</li><li>At runtime, we have $G$ that has a Gaussian distribution, we use $f$ to blend the three initial pixels while preserving the Gaussian distribution to get $f(G)$, and we use the precomputed look-up table to apply it to $T^{-1}$. This step can be done in the fragment shader.</li></ul><p><img src=/images/histogram_article/hist_step2.png alt="Step 2 of the algorithm"></p><p>After the third step, we have effectively computed:</p><p>$$T^{-1}[f(G)] = T^{-1}[f(T(X))] = X&rsquo;$$</p><p><img src=/images/histogram_article/hist_step3.png alt="Step 3 of the algorithm"></p><p>And we have our final color that follows the same histogram as the input color. Tadam.</p><p>To conclude, we have in our hand a fast method to generate big textures that have the same histogram and therefore the same features as the smaller input textures. The authors have provided an explanative <a href=https://drive.google.com/file/d/1YS8RHNcYff7ReroiBbeXHZ79L0_KrSK6/view>video</a> to show some impressive results in real-time.</p><hr><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>A better explanation of color histograms can be found <a href=https://thecoffeelicious.com/a-photographers-guide-to-color-histogram-e31a5d92efb2>here</a>.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>The exact formula for this operator is: $$X&rsquo; = \frac{\sum w_i X_i - \mathbb{E}[X]}{W} + \mathbb{E}[X]$$ where $$W = \sqrt{\sum w_i^2}$$&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Optimal Transport is a huge topic. There is a <a href=http://cedricvillani.org/wp-content/uploads/2012/08/preprint-1.pdf>book</a> written by Cedric Villani on the subject, and you can find a reference implementation by Bonneel <a href=https://perso.liris.cnrs.fr/nicolas.bonneel/FastTransport/>there</a>.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=content__footer></footer></section><section class=page__aside><div class=aside__about><div class=aside__about><h1 class=about__title>rivten</h1><p class=about__description>stuck here</p></div><ul class=aside__social-links></ul></div><hr><div class=aside__content><p>by Hugo Viala,
2018-07-07</p></div></section><footer class=page__footer><p class=copyright></p></footer></div></body></html>